#!/usr/bin/env node

const Database = require(require('path').join(__dirname, '..', 'node_modules', 'better-sqlite3'));
const fs = require('fs');
const crypto = require('crypto');
const path = require('path');
const os = require('os');

const DB_PATH = path.join(os.homedir(), 'clawd', 'comms.db');
const ATTACHMENTS_DIR = path.join(os.homedir(), 'clawd', 'data', 'attachments');
const VALID_AGENTS = ['ralph', 'orion', 'devin', 'scout', 'quinn', 'porter', 'cluma', 'connor'];
const GATEWAY_URL = process.env.OPENCLAW_GATEWAY_URL || 'http://127.0.0.1:18789';
const GATEWAY_TOKEN = process.env.OPENCLAW_GATEWAY_TOKEN || (() => {
  try {
    const envFile = require('fs').readFileSync(path.join(os.homedir(), '.openclaw', '.env'), 'utf8');
    const match = envFile.match(/OPENCLAW_GATEWAY_TOKEN=(.+)/);
    return match ? match[1].trim() : '';
  } catch { return ''; }
})();
const AGENT_IDS = { orion: 'orion', devin: 'devin', scout: 'scout', quinn: 'quinn', porter: 'porter', cluma: 'cluma' };
const ALL_AGENTS = ['ralph', 'orion', 'devin', 'scout', 'quinn', 'porter', 'cluma'];

function extractMentions(body) {
  const mentionRegex = /@(ralph|orion|devin|scout|quinn|porter|cluma)\b/gi;
  const matches = body.match(mentionRegex) || [];
  return [...new Set(matches.map(m => m.slice(1).toLowerCase()))];
}

function getRalphPayload(threadId) {
  return `Connor posted a new message in Squad Comms thread #${threadId}.

STEP 1: Read the full thread for context:
~/clawd/bin/comms thread ${threadId}

STEP 2: Use memory_search if you need background on the topic.

STEP 3: Decide what action to take:
- If Connor approved something - @mention the agent to execute
- If Connor asked a question - answer directly or @mention the right specialist
- If Connor gave new direction - update the thread and @mention relevant agent(s)
- If it is just an acknowledgment - respond briefly, no delegation needed

STEP 4: Post your response:
~/clawd/bin/comms send --thread ${threadId} --from ralph --body '<your response>'

To wake a specialist agent, include @agentname (e.g., @devin, @scout) in your message body.
The system will automatically spawn them with thread context.`;
}

function getMentionPayload(threadId, fromAgent, agentName) {
  return `You were @mentioned in Squad Comms thread #${threadId} by ${fromAgent}.

STEP 1: Read the full thread:
~/clawd/bin/comms thread ${threadId}

STEP 2: Understand the context and what is being asked of you.

STEP 3: Execute the task, answer the question, or continue the conversation.

STEP 4: Post your response/update:
~/clawd/bin/comms send --thread ${threadId} --from ${agentName} --body '<your response>'

If you need to delegate to another agent, include @agentname in your message.`;
}

function getDb() {
  const db = new Database(DB_PATH);
  db.pragma('journal_mode = WAL');
  db.pragma('foreign_keys = ON');
  // Migration: add 'paused' to threads status if not already supported
  try {
    const schema = db.prepare("SELECT sql FROM sqlite_master WHERE type='table' AND name='threads'").get();
    if (schema && schema.sql && !schema.sql.includes("'paused'")) {
      db.exec(`
        PRAGMA foreign_keys = OFF;
        BEGIN TRANSACTION;
        CREATE TABLE threads_new (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          title TEXT NOT NULL,
          channel_id TEXT NOT NULL DEFAULT 'general',
          task_id TEXT,
          status TEXT NOT NULL DEFAULT 'active' CHECK(status IN ('active', 'resolved', 'blocked', 'archived', 'paused')),
          created_by TEXT NOT NULL,
          created_at TEXT NOT NULL DEFAULT (datetime('now')),
          updated_at TEXT NOT NULL DEFAULT (datetime('now')),
          FOREIGN KEY (channel_id) REFERENCES channels(id)
        );
        INSERT INTO threads_new SELECT * FROM threads;
        DROP TABLE threads;
        ALTER TABLE threads_new RENAME TO threads;
        COMMIT;
        PRAGMA foreign_keys = ON;
      `);
    }
  } catch (e) { /* table may not exist yet */ }
  
  // Migration: ensure attachments table has path column
  try {
    db.exec("ALTER TABLE attachments ADD COLUMN path TEXT DEFAULT ''");
  } catch (e) { /* column already exists */ }
  return db;
}

function parseArgs(args) {
  const result = { _: [] };
  for (let i = 0; i < args.length; i++) {
    if (args[i].startsWith('--')) {
      const key = args[i].slice(2);
      if (i + 1 < args.length && !args[i + 1].startsWith('--')) {
        result[key] = args[i + 1];
        i++;
      } else {
        result[key] = true;
      }
    } else {
      result._.push(args[i]);
    }
  }
  return result;
}

function output(ok, data, summary) {
  console.log(JSON.stringify({ ok, data, summary }));
  if (summary) process.stderr.write(summary + '\n');
}

// Wake a single agent via one-shot cron job
async function wakeOneAgent(agent, threadId, payload) {
  const http = require('http');
  const agentId = agent === 'ralph' ? 'main' : agent;
  return new Promise((resolve) => {
    const now = new Date(Date.now() + 3000).toISOString();
    const body = JSON.stringify({
      tool: 'cron',
      args: {
        action: 'add',
        job: {
          name: `comms-wake-${agent}-t${threadId}-${Date.now()}`,
          agentId,
          schedule: { kind: 'at', at: now },
          sessionTarget: 'isolated',
          deleteAfterRun: true,
          payload: { kind: 'agentTurn', message: payload },
          delivery: { mode: 'none' },
          enabled: true
        }
      }
    });
    const url = new URL(GATEWAY_URL + '/tools/invoke');
    const req = http.request({
      hostname: url.hostname,
      port: url.port,
      path: url.pathname,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(body),
        ...(GATEWAY_TOKEN ? { 'Authorization': `Bearer ${GATEWAY_TOKEN}` } : {})
      },
      timeout: 10000
    }, (res) => {
      let data = '';
      res.on('data', c => data += c);
      res.on('end', () => {
        try { resolve({ agent, ok: JSON.parse(data).ok !== false }); }
        catch { resolve({ agent, ok: false }); }
      });
    });
    req.on('error', () => resolve({ agent, ok: false }));
    req.on('timeout', () => { req.destroy(); resolve({ agent, ok: false }); });
    req.write(body);
    req.end();
  });
}

// Push-based wake routing: Connor -> Ralph, @mentions -> specific agents
async function wakeAgents(agents, threadId, fromAgent, msgBody) {
  const mentions = extractMentions(msgBody || '');
  const toWake = [];

  // Connor's messages always wake Ralph
  if (fromAgent === 'connor') {
    toWake.push({ agent: 'ralph', payload: getRalphPayload(threadId) });
  }

  // @mentions wake the mentioned agents (but never the sender)
  for (const mentioned of mentions) {
    if (mentioned !== fromAgent && ALL_AGENTS.includes(mentioned)) {
      toWake.push({
        agent: mentioned,
        payload: mentioned === 'ralph'
          ? getRalphPayload(threadId)
          : getMentionPayload(threadId, fromAgent, mentioned)
      });
    }
  }

  // Deduplicate
  const seen = new Set();
  const unique = toWake.filter(w => {
    if (seen.has(w.agent)) return false;
    seen.add(w.agent);
    return true;
  });

  if (unique.length === 0) return [];

  const results = await Promise.all(unique.map(w => wakeOneAgent(w.agent, threadId, w.payload)));
  const woken = results.filter(r => r.ok).map(r => r.agent);
  if (woken.length > 0) {
    process.stderr.write(`Woke agents: ${woken.join(', ')}\n`);
  }
  return woken;
}

function error(msg) {
  console.log(JSON.stringify({ ok: false, error: msg }));
  process.stderr.write('Error: ' + msg + '\n');
  process.exit(1);
}

function validateAgent(agent) {
  if (!VALID_AGENTS.includes(agent)) {
    error(`Invalid agent "${agent}". Valid agents: ${VALID_AGENTS.join(', ')}`);
  }
}

// ---- COMMANDS ----

function cmdInit() {
  const db = getDb();
  db.exec(`
    CREATE TABLE IF NOT EXISTS channels (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      description TEXT,
      type TEXT NOT NULL CHECK(type IN ('public', 'dm', 'thread')),
      created_at TEXT NOT NULL DEFAULT (datetime('now'))
    );

    CREATE TABLE IF NOT EXISTS threads (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      channel_id TEXT NOT NULL DEFAULT 'general',
      task_id TEXT,
      status TEXT NOT NULL DEFAULT 'active' CHECK(status IN ('active', 'resolved', 'blocked', 'archived', 'paused')),
      created_by TEXT NOT NULL,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now')),
      FOREIGN KEY (channel_id) REFERENCES channels(id)
    );

    CREATE TABLE IF NOT EXISTS thread_members (
      thread_id INTEGER NOT NULL,
      agent TEXT NOT NULL,
      joined_at TEXT NOT NULL DEFAULT (datetime('now')),
      PRIMARY KEY (thread_id, agent),
      FOREIGN KEY (thread_id) REFERENCES threads(id)
    );

    CREATE TABLE IF NOT EXISTS messages (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      thread_id INTEGER NOT NULL,
      from_agent TEXT NOT NULL,
      body TEXT NOT NULL,
      importance TEXT NOT NULL DEFAULT 'normal' CHECK(importance IN ('low', 'normal', 'high', 'urgent')),
      metadata TEXT,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      FOREIGN KEY (thread_id) REFERENCES threads(id)
    );

    CREATE TABLE IF NOT EXISTS read_receipts (
      message_id INTEGER NOT NULL,
      agent TEXT NOT NULL,
      read_at TEXT NOT NULL DEFAULT (datetime('now')),
      PRIMARY KEY (message_id, agent),
      FOREIGN KEY (message_id) REFERENCES messages(id)
    );

    CREATE TABLE IF NOT EXISTS agent_presence (
      agent TEXT PRIMARY KEY,
      status TEXT NOT NULL DEFAULT 'idle' CHECK(status IN ('idle', 'working', 'checking-comms', 'offline')),
      last_seen TEXT NOT NULL DEFAULT (datetime('now')),
      current_task TEXT,
      last_thread_id INTEGER
    );
  `);

  // FTS - create only if not exists
  try {
    db.exec(`CREATE VIRTUAL TABLE IF NOT EXISTS messages_fts USING fts5(body, content=messages, content_rowid=id);`);
  } catch (e) {
    // already exists
  }

  // Triggers
  const triggers = [
    { name: 'messages_ai', sql: `CREATE TRIGGER IF NOT EXISTS messages_ai AFTER INSERT ON messages BEGIN INSERT INTO messages_fts(rowid, body) VALUES (new.id, new.body); END;` },
    { name: 'messages_ad', sql: `CREATE TRIGGER IF NOT EXISTS messages_ad AFTER DELETE ON messages BEGIN INSERT INTO messages_fts(messages_fts, rowid, body) VALUES('delete', old.id, old.body); END;` },
    { name: 'messages_au', sql: `CREATE TRIGGER IF NOT EXISTS messages_au AFTER UPDATE ON messages BEGIN INSERT INTO messages_fts(messages_fts, rowid, body) VALUES('delete', old.id, old.body); INSERT INTO messages_fts(rowid, body) VALUES (new.id, new.body); END;` },
  ];
  for (const t of triggers) {
    try { db.exec(t.sql); } catch (e) { /* already exists */ }
  }

  // Seed channels
  const insertChannel = db.prepare(`INSERT OR IGNORE INTO channels (id, name, description, type) VALUES (?, ?, ?, ?)`);
  const channels = [
    ['general', '#general', 'Team-wide announcements and coordination', 'public'],
    ['handoffs', '#handoffs', 'Task handoffs between agents', 'public'],
    ['urgent', '#urgent', 'Time-sensitive items needing immediate attention', 'public'],
    ['status', '#status', 'Status updates and check-ins', 'public'],
    ['ralph-devin', 'Ralph <> Devin', 'Direct messages', 'dm'],
    ['ralph-orion', 'Ralph <> Orion', 'Direct messages', 'dm'],
    ['ralph-scout', 'Ralph <> Scout', 'Direct messages', 'dm'],
    ['ralph-quinn', 'Ralph <> Quinn', 'Direct messages', 'dm'],
    ['ralph-porter', 'Ralph <> Porter', 'Direct messages', 'dm'],
  ];
  for (const c of channels) insertChannel.run(...c);

  // Seed agent presence
  const insertPresence = db.prepare(`INSERT OR IGNORE INTO agent_presence (agent, status, last_seen) VALUES (?, 'idle', datetime('now'))`);
  for (const a of ['ralph', 'orion', 'devin', 'scout', 'quinn', 'porter']) {
    insertPresence.run(a);
  }

  db.close();
  output(true, { database: DB_PATH }, 'Database initialized and seeded successfully.');
}

function cmdSend(flags) {
  if (!flags.from) error('--from is required');
  if (!flags.thread) error('--thread is required');
  if (!flags.body) error('--body is required');
  validateAgent(flags.from);

  const db = getDb();
  const thread = db.prepare('SELECT id, status FROM threads WHERE id = ?').get(Number(flags.thread));
  if (!thread) error(`Thread ${flags.thread} not found. Use "comms threads" to list threads.`);
  if (thread.status === 'paused') {
    db.close();
    error(`Thread is paused. Resume it first with: comms thread resume ${flags.thread}`);
  }

  const importance = flags.importance || 'normal';
  const metadata = flags.session ? JSON.stringify({ session_id: flags.session }) : null;
  const result = db.prepare('INSERT INTO messages (thread_id, from_agent, body, importance, metadata) VALUES (?, ?, ?, ?, ?)').run(Number(flags.thread), flags.from, flags.body, importance, metadata);
  db.prepare('UPDATE threads SET updated_at = datetime(\'now\') WHERE id = ?').run(Number(flags.thread));
  db.prepare('UPDATE agent_presence SET last_seen = datetime(\'now\'), last_thread_id = ? WHERE agent = ?').run(Number(flags.thread), flags.from);

  // Auto-add sender as member if not already
  db.prepare('INSERT OR IGNORE INTO thread_members (thread_id, agent) VALUES (?, ?)').run(Number(flags.thread), flags.from);

  // Handle file attachment
  if (flags.file) {
    const filePath = path.resolve(flags.file);
    if (!fs.existsSync(filePath)) {
      db.close();
      error('File not found: ' + flags.file);
    }
    const stat = fs.statSync(filePath);
    const originalName = path.basename(filePath);
    const ext = path.extname(originalName);
    const hash = crypto.randomBytes(8).toString('hex');
    const filename = hash + ext;
    const mime = require('child_process').execSync('file --mime-type -b ' + JSON.stringify(filePath), { encoding: 'utf8' }).trim();

    // Ensure attachments dir exists
    fs.mkdirSync(ATTACHMENTS_DIR, { recursive: true });
    const destPath = path.join(ATTACHMENTS_DIR, filename);
    fs.copyFileSync(filePath, destPath);

    db.prepare('INSERT INTO attachments (message_id, filename, original_name, mime_type, size_bytes, path) VALUES (?, ?, ?, ?, ?, ?)').run(
      result.lastInsertRowid, filename, originalName, mime, stat.size, destPath
    );
  }


  // Get thread members for waking
  const members = db.prepare('SELECT agent FROM thread_members WHERE thread_id = ?').all(Number(flags.thread)).map(r => r.agent);

  db.close();
  output(true, { message_id: result.lastInsertRowid, thread_id: Number(flags.thread), created_at: new Date().toISOString() }, `Sent message #${result.lastInsertRowid} to thread #${flags.thread}`);

  // Wake agents unless --no-wake is set
  if (!flags['no-wake']) {
    wakeAgents(members, Number(flags.thread), flags.from, flags.body).catch(() => {});
  }
}

function cmdNewThread(flags) {
  if (!flags.title) error('--title is required');
  if (!flags.from) error('--from is required');
  validateAgent(flags.from);

  const channel = flags.channel || 'general';
  const db = getDb();

  const ch = db.prepare('SELECT id FROM channels WHERE id = ?').get(channel);
  if (!ch) error(`Channel "${channel}" not found.`);

  // Auto-create Loop task unless --no-task or --task is provided
  let taskId = flags.task || null;
  if (!taskId && !flags['no-task']) {
    try {
      const LOOP_PATH = path.join(os.homedir(), 'clawd', 'scripts', 'loop');
      const { execSync } = require('child_process');
      const agents = flags.agents ? flags.agents.split(',').map(a => a.trim()) : [flags.from];
      const assignee = agents.find(a => a !== 'ralph' && a !== 'connor') || flags.from;
      const priorityMap = { '1': 'critical', '2': 'high', '3': 'medium' };
      const priority = priorityMap[flags.priority] || 'high';
      const labels = [channel, 'squad-comms'].join(',');
      const loopResult = execSync(
        `${LOOP_PATH} add "${flags.title}" --agentic --agent ${assignee} -P ${priority} --labels "${labels}"`,
        { cwd: path.join(os.homedir(), 'clawd'), encoding: 'utf8', timeout: 10000 }
      );
      // loop add outputs the ID as last line
      const lines = loopResult.trim().split('\n');
      const lastLine = lines[lines.length - 1].trim();
      if (/^\d+$/.test(lastLine)) taskId = lastLine;
    } catch (e) {
      process.stderr.write(`Warning: Could not auto-create Loop task: ${e.message}\n`);
    }
  }

  const result = db.prepare('INSERT INTO threads (title, channel_id, task_id, created_by) VALUES (?, ?, ?, ?)').run(flags.title, channel, taskId, flags.from);
  const threadId = result.lastInsertRowid;

  // If we created a task, link it to the thread
  if (taskId && !flags.task) {
    try {
      const LOOP_PATH = path.join(os.homedir(), 'clawd', 'scripts', 'loop');
      const { execSync } = require('child_process');
      execSync(`${LOOP_PATH} update ${taskId} --thread ${threadId} --notes "Squad Comms Thread #${threadId}. ${flags.title}"`,
        { cwd: path.join(os.homedir(), 'clawd'), encoding: 'utf8', timeout: 10000 });
    } catch (e) { /* non-fatal */ }
  }

  // Add members
  const agents = flags.agents ? flags.agents.split(',').map(a => a.trim()) : [];
  if (!agents.includes(flags.from)) agents.push(flags.from);
  const insertMember = db.prepare('INSERT OR IGNORE INTO thread_members (thread_id, agent) VALUES (?, ?)');
  for (const a of agents) {
    validateAgent(a);
    insertMember.run(threadId, a);
  }

  // System message
  db.prepare('INSERT INTO messages (thread_id, from_agent, body, importance) VALUES (?, ?, ?, ?)').run(threadId, 'system', `[${flags.from} created thread: ${flags.title}]`, 'low');

  db.close();
  output(true, { thread_id: threadId, title: flags.title, channel: channel, members: agents, task_id: taskId }, `Created thread #${threadId}: ${flags.title}${taskId ? ` (Loop: #${taskId})` : ''}`);

  // Wake agents unless --no-wake is set
  if (!flags['no-wake']) {
    wakeAgents(agents, threadId, flags.from, flags.title).catch(() => {});
  }
}

function cmdSyncTasks() {
  // Find threads without linked Loop tasks and create them
  const db = getDb();
  const orphanThreads = db.prepare(`
    SELECT t.*, GROUP_CONCAT(tm.agent) as members_str
    FROM threads t
    LEFT JOIN thread_members tm ON tm.thread_id = t.id
    WHERE t.task_id IS NULL AND t.status IN ('active', 'blocked')
    GROUP BY t.id
  `).all();

  if (orphanThreads.length === 0) {
    db.close();
    output(true, { synced: 0 }, 'All threads have linked tasks. Nothing to sync.');
    return;
  }

  const LOOP_PATH = path.join(os.homedir(), 'clawd', 'scripts', 'loop');
  const { execSync } = require('child_process');
  const synced = [];

  for (const t of orphanThreads) {
    try {
      const members = t.members_str ? t.members_str.split(',') : ['ralph'];
      const assignee = members.find(a => a !== 'ralph' && a !== 'connor' && a !== 'system') || 'ralph';
      const loopResult = execSync(
        `${LOOP_PATH} add "${t.title}" --agentic --agent ${assignee} -P high --labels "${t.channel_id},squad-comms" --thread ${t.id}`,
        { cwd: path.join(os.homedir(), 'clawd'), encoding: 'utf8', timeout: 10000 }
      );
      const lines = loopResult.trim().split('\n');
      const lastLine = lines[lines.length - 1].trim();
      if (/^\d+$/.test(lastLine)) {
        const taskId = lastLine;
        db.prepare('UPDATE threads SET task_id = ?, updated_at = datetime(\'now\') WHERE id = ?').run(taskId, t.id);
        synced.push({ thread_id: t.id, title: t.title, task_id: taskId });
      }
    } catch (e) {
      process.stderr.write(`Warning: Failed to create loop for thread #${t.id}: ${e.message}\n`);
    }
  }

  db.close();
  output(true, { synced: synced.length, details: synced }, `Synced ${synced.length} thread(s) with new Loop tasks`);
}

function cmdInbox(flags) {
  if (!flags.agent) error('--agent is required');
  validateAgent(flags.agent);

  const limit = Number(flags.limit) || 50;
  const db = getDb();

  let query;
  if (flags.all) {
    query = db.prepare(`
      SELECT m.*, t.title as thread_title, t.channel_id, t.status as thread_status
      FROM messages m
      JOIN threads t ON m.thread_id = t.id
      JOIN thread_members tm ON tm.thread_id = t.id AND tm.agent = ?
      WHERE m.from_agent != ?
      ORDER BY m.created_at DESC
      LIMIT ?
    `);
  } else {
    query = db.prepare(`
      SELECT m.*, t.title as thread_title, t.channel_id, t.status as thread_status
      FROM messages m
      JOIN threads t ON m.thread_id = t.id
      JOIN thread_members tm ON tm.thread_id = t.id AND tm.agent = ?
      WHERE m.from_agent != ?
        AND m.from_agent != 'system'
        AND NOT EXISTS (SELECT 1 FROM read_receipts rr WHERE rr.message_id = m.id AND rr.agent = ?)
      ORDER BY m.created_at DESC
      LIMIT ?
    `);
  }

  const messages = flags.all
    ? query.all(flags.agent, flags.agent, limit)
    : query.all(flags.agent, flags.agent, flags.agent, limit);

  // Mark as read
  const markRead = db.prepare('INSERT OR IGNORE INTO read_receipts (message_id, agent) VALUES (?, ?)');
  for (const m of messages) markRead.run(m.id, flags.agent);

  db.prepare('UPDATE agent_presence SET last_seen = datetime(\'now\'), status = \'checking-comms\' WHERE agent = ?').run(flags.agent);

  db.close();
  output(true, { messages, count: messages.length }, `${messages.length} message(s) for ${flags.agent}`);
}

function cmdThreadPause(flags) {
  const threadId = Number(flags._[0]);
  if (!threadId) error('Thread ID is required. Usage: comms thread pause <id>');
  const db = getDb();
  const thread = db.prepare('SELECT id FROM threads WHERE id = ?').get(threadId);
  if (!thread) error(`Thread ${threadId} not found.`);
  db.prepare("UPDATE threads SET status = 'paused', updated_at = datetime('now') WHERE id = ?").run(threadId);
  db.close();
  output(true, { thread_id: threadId, status: 'paused' }, `Thread #${threadId} paused.`);
}

function cmdThreadResume(flags) {
  const threadId = Number(flags._[0]);
  if (!threadId) error('Thread ID is required. Usage: comms thread resume <id>');
  const db = getDb();
  const thread = db.prepare('SELECT id FROM threads WHERE id = ?').get(threadId);
  if (!thread) error(`Thread ${threadId} not found.`);
  db.prepare("UPDATE threads SET status = 'active', updated_at = datetime('now') WHERE id = ?").run(threadId);
  db.close();
  output(true, { thread_id: threadId, status: 'active' }, `Thread #${threadId} resumed.`);
}

function cmdThreadList() {
  const db = getDb();
  const threads = db.prepare(`
    SELECT t.id, t.title, t.channel_id, t.status, t.created_by, t.updated_at,
      (SELECT COUNT(*) FROM messages m WHERE m.thread_id = t.id) as message_count
    FROM threads t ORDER BY t.updated_at DESC
  `).all();
  db.close();
  const lines = threads.map(t => `#${t.id} [${t.status}] ${t.title} (${t.channel_id}, ${t.message_count} msgs)`).join('\n');
  output(true, { threads, count: threads.length }, `${threads.length} thread(s):\n${lines}`);
}

function cmdThread(flags) {
  const subCmd = flags._[0];
  if (subCmd === 'pause') { flags._ = flags._.slice(1); return cmdThreadPause(flags); }
  if (subCmd === 'resume') { flags._ = flags._.slice(1); return cmdThreadResume(flags); }
  if (subCmd === 'list') { return cmdThreadList(); }

  const threadId = Number(flags._[0]);
  if (!threadId) error('Thread ID is required. Usage: comms thread <id>');

  const limit = Number(flags.limit) || 100;
  const offset = Number(flags.offset) || 0;
  const db = getDb();

  const thread = db.prepare('SELECT * FROM threads WHERE id = ?').get(threadId);
  if (!thread) error(`Thread ${threadId} not found.`);

  const members = db.prepare('SELECT agent FROM thread_members WHERE thread_id = ?').all(threadId).map(r => r.agent);
  const messages = db.prepare('SELECT * FROM messages WHERE thread_id = ? ORDER BY created_at ASC LIMIT ? OFFSET ?').all(threadId, limit, offset);

  // Attach attachment info to each message
  const attStmt = db.prepare('SELECT id, filename, original_name, mime_type, size_bytes FROM attachments WHERE message_id = ?');
  const ATTACHMENTS_DIR = path.join(os.homedir(), 'clawd', 'mission-control', 'data', 'attachments');
  for (const msg of messages) {
    const atts = attStmt.all(msg.id);
    if (atts.length > 0) {
      msg.attachments = atts.map(a => ({
        ...a,
        path: path.join(ATTACHMENTS_DIR, a.filename),
      }));
    }
  }

  db.close();
  output(true, { thread: { ...thread, members }, messages }, `Thread #${threadId}: ${thread.title} (${messages.length} messages)`);
}

function cmdThreads(flags) {
  if (!flags.agent) error('--agent is required');
  validateAgent(flags.agent);

  const db = getDb();
  let conditions = ['tm.agent = ?'];
  let params = [flags.agent];

  if (flags.status) {
    conditions.push('t.status = ?');
    params.push(flags.status);
  }
  if (flags.channel) {
    conditions.push('t.channel_id = ?');
    params.push(flags.channel);
  }

  const threads = db.prepare(`
    SELECT t.*,
      (SELECT COUNT(*) FROM messages m WHERE m.thread_id = t.id
        AND m.from_agent != ? AND m.from_agent != 'system'
        AND NOT EXISTS (SELECT 1 FROM read_receipts rr WHERE rr.message_id = m.id AND rr.agent = ?)) as unread_count,
      (SELECT body FROM messages m2 WHERE m2.thread_id = t.id ORDER BY m2.created_at DESC LIMIT 1) as last_message
    FROM threads t
    JOIN thread_members tm ON tm.thread_id = t.id
    WHERE ${conditions.join(' AND ')}
    ORDER BY t.updated_at DESC
  `).all(flags.agent, flags.agent, ...params);

  // Get members for each thread
  const getMembersStmt = db.prepare('SELECT agent FROM thread_members WHERE thread_id = ?');
  for (const t of threads) {
    t.members = getMembersStmt.all(t.id).map(r => r.agent);
  }

  db.close();
  output(true, { threads, count: threads.length }, `${threads.length} thread(s) for ${flags.agent}`);
}

function cmdUpdateThread(flags) {
  const threadId = Number(flags._[0]);
  if (!threadId) error('Thread ID is required. Usage: comms update-thread <id> [--status ...] [--add-agent ...] [--remove-agent ...]');

  const db = getDb();
  const thread = db.prepare('SELECT id FROM threads WHERE id = ?').get(threadId);
  if (!thread) error(`Thread ${threadId} not found.`);

  if (flags.status) {
    db.prepare('UPDATE threads SET status = ?, updated_at = datetime(\'now\') WHERE id = ?').run(flags.status, threadId);
  }
  if (flags['add-agent']) {
    validateAgent(flags['add-agent']);
    db.prepare('INSERT OR IGNORE INTO thread_members (thread_id, agent) VALUES (?, ?)').run(threadId, flags['add-agent']);
  }
  if (flags['remove-agent']) {
    db.prepare('DELETE FROM thread_members WHERE thread_id = ? AND agent = ?').run(threadId, flags['remove-agent']);
  }

  const updated = db.prepare('SELECT * FROM threads WHERE id = ?').get(threadId);
  const members = db.prepare('SELECT agent FROM thread_members WHERE thread_id = ?').all(threadId).map(r => r.agent);

  db.close();
  output(true, { thread: { ...updated, members } }, `Updated thread #${threadId}`);
}

function cmdPresence(flags) {
  const db = getDb();

  if (flags.all) {
    const agents = db.prepare('SELECT * FROM agent_presence ORDER BY agent').all();
    db.close();
    output(true, { agents }, `${agents.length} agents`);
    return;
  }

  if (!flags.agent) error('--agent or --all is required');
  validateAgent(flags.agent);

  if (flags.status || flags.task) {
    const updates = [];
    const params = [];
    if (flags.status) { updates.push('status = ?'); params.push(flags.status); }
    if (flags.task) { updates.push('current_task = ?'); params.push(flags.task); }
    updates.push("last_seen = datetime('now')");
    params.push(flags.agent);
    db.prepare(`UPDATE agent_presence SET ${updates.join(', ')} WHERE agent = ?`).run(...params);
  }

  const agent = db.prepare('SELECT * FROM agent_presence WHERE agent = ?').get(flags.agent);
  db.close();
  output(true, { agent }, `Presence for ${flags.agent}: ${agent?.status || 'unknown'}`);
}

function cmdSearch(flags) {
  const query = flags._[0];
  if (!query) error('Search query is required. Usage: comms search "query"');

  const limit = Number(flags.limit) || 20;
  const db = getDb();

  let sql = `
    SELECT m.*, t.title as thread_title, t.channel_id
    FROM messages_fts fts
    JOIN messages m ON m.id = fts.rowid
    JOIN threads t ON t.id = m.thread_id
    WHERE messages_fts MATCH ?
  `;
  const params = [query];

  if (flags.agent) {
    sql += ' AND m.from_agent = ?';
    params.push(flags.agent);
  }
  sql += ' ORDER BY m.created_at DESC LIMIT ?';
  params.push(limit);

  const results = db.prepare(sql).all(...params);
  db.close();
  output(true, { results, count: results.length }, `${results.length} result(s) for "${query}"`);
}

function cmdStats() {
  const db = getDb();

  const totalThreads = db.prepare('SELECT COUNT(*) as count FROM threads').get().count;
  const activeThreads = db.prepare("SELECT COUNT(*) as count FROM threads WHERE status = 'active'").get().count;
  const totalMessages = db.prepare('SELECT COUNT(*) as count FROM messages').get().count;
  const messagesToday = db.prepare("SELECT COUNT(*) as count FROM messages WHERE created_at >= date('now')").get().count;

  // Unread per agent
  const agents = ['ralph', 'orion', 'devin', 'scout', 'quinn', 'porter'];
  const unreadPerAgent = {};
  const unreadStmt = db.prepare(`
    SELECT COUNT(*) as count FROM messages m
    JOIN thread_members tm ON tm.thread_id = m.thread_id AND tm.agent = ?
    WHERE m.from_agent != ? AND m.from_agent != 'system'
      AND NOT EXISTS (SELECT 1 FROM read_receipts rr WHERE rr.message_id = m.id AND rr.agent = ?)
  `);
  for (const a of agents) {
    unreadPerAgent[a] = unreadStmt.get(a, a, a).count;
  }

  const presence = db.prepare('SELECT * FROM agent_presence ORDER BY agent').all();

  db.close();
  output(true, {
    total_threads: totalThreads,
    active_threads: activeThreads,
    total_messages: totalMessages,
    messages_today: messagesToday,
    unread_per_agent: unreadPerAgent,
    agent_presence: presence,
  }, `Stats: ${totalThreads} threads, ${totalMessages} messages, ${messagesToday} today`);
}


function cmdAttachments(flags) {
  const threadId = Number(flags.thread || flags._[0]);
  if (!threadId) error('--thread or thread ID is required. Usage: comms attachments --thread <id>');

  const db = getDb();
  const thread = db.prepare('SELECT id, title FROM threads WHERE id = ?').get(threadId);
  if (!thread) error('Thread ' + threadId + ' not found.');

  const attachments = db.prepare(`
    SELECT a.*, m.from_agent, m.created_at as message_date
    FROM attachments a
    JOIN messages m ON m.id = a.message_id
    WHERE m.thread_id = ?
    ORDER BY a.created_at DESC
  `).all(threadId);

  db.close();
  const lines = attachments.map(a => a.original_name + ' (' + a.mime_type + ', ' + a.size_bytes + ' bytes) from ' + a.from_agent).join('\n');
  output(true, { attachments, count: attachments.length, thread_id: threadId }, attachments.length + ' attachment(s) in thread #' + threadId + (lines ? ':\n' + lines : ''));
}

// ---- MAIN ----
const args = process.argv.slice(2);
const command = args[0];
const flags = parseArgs(args.slice(1));

switch (command) {
  case 'init': cmdInit(); break;
  case 'send': cmdSend(flags); break;
  case 'new-thread': cmdNewThread(flags); break;
  case 'inbox': cmdInbox(flags); break;
  case 'thread': cmdThread(flags); break;
  case 'threads': cmdThreads(flags); break;
  case 'update-thread': cmdUpdateThread(flags); break;
  case 'presence': cmdPresence(flags); break;
  case 'search': cmdSearch(flags); break;
  case 'stats': cmdStats(); break;
  case 'attachments': cmdAttachments(flags); break;
  case 'sync-tasks': cmdSyncTasks(); break;
  default:
    console.log(JSON.stringify({
      ok: false,
      error: `Unknown command: ${command || '(none)'}`,
      usage: 'comms <init|send|new-thread|inbox|thread|threads|update-thread|presence|search|stats|attachments>'
    }));
    process.exit(1);
}
